<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码量和线段树相比少了好多。</p></blockquote><p>树状数组所能解决的问题使用线段树均能解决。</p><p>主要用于求解快速前缀和——在O(logn)的时间内完成<strong>单点修改</strong>与<strong>区间查询</strong>（前缀和）。</p><p>树状数组理论上只能完成单点修改与区间查询，其他的问题均是转换为这一问题去处理。如（区间修改、单点修改 | 区间修改、区间查询）。</p><blockquote><p>括号的内容太复杂了，y总说蓝桥杯不考…</p><p>​--2022-3-31 17:28</p></blockquote><h2 id="1存储组织"><a class="markdownIt-Anchor" href="#1存储组织"></a> 1.存储组织</h2><p>树状数组与原数组的关系可以用下图表示(图片来自<a href="https://www.cnblogs.com/xenny/p/9739600.html">博客</a>)：</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202203301620592.png" alt="image-20220330162018488" /></p><p>黑色数组代表原数组(a)。红色结构则代表树状数组©，存储的值是其全部子结点的值之和。可以看出:</p><p>c[1] = a[1]</p><p>c[2] = a[1] + a[2]</p><p>c[3] = a[3]</p><p>c[4] = a[1] + a[2] + a[3] + a[4]</p><p>…</p><p>c[8] = a[1] + a[2] + … + a[8]</p><p>我们定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为索引<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>二进制表示中末尾连续0的个数。那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(a[i - 2^k], a[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>的所有元素和。</p><h2 id="2k的求解"><a class="markdownIt-Anchor" href="#2k的求解"></a> 2.k的求解</h2><p>为了建立树状数组，我们首先要求解出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>。这里利用了负数在计算机中的存储特性来求解。</p><p>负数在计算机中以补码存储。对于运算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \&amp; (-x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>：</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">&amp;</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \&amp; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">0</span></span></span></span>结果仍为0.</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为奇数时，最后一位二进制数为1，取反加1后最后一位仍然为1，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">x</span></span></span></span>除最后一位相同外，其余位均相反，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x \&amp; (-x) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。正好满足了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为偶数时，且为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次方时，此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>最后有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>位0，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>取反加一后，末尾正好有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>位0，其余位均为1，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \&amp; (-x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为偶数，且不为2的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次方时，可以将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>表示为一个奇数左移<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>位，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = y × (2 ^ k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的二进制表示下，最右边有连续<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个0，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位为1。取反加一后，最右侧仍为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个0， 第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位为1，其余位均与原数不同，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">x \&amp; (-x) = 2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>。</li></ul><p>故，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \&amp; (-x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>可以求得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的值。</p><h2 id="3索引关系"><a class="markdownIt-Anchor" href="#3索引关系"></a> 3.索引关系</h2><p>为了应付蓝桥杯，这里选择记住，特别是第二点：</p><ul><li>树状数组索引从1开始。</li><li>索引为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的节点，其父节点索引为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x + lowbit(x) = x + (x \&amp; (-x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="4相关代码"><a class="markdownIt-Anchor" href="#4相关代码"></a> 4.相关代码</h2><p>我们使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>数组表示原数组，使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">tree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span></span></span></span>数组表示树状数组（索引从1至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>）</p><h3 id="41建树"><a class="markdownIt-Anchor" href="#41建树"></a> 4.1建树</h3><p>我们将树状数组初始化为全0，那么建树的过程可以看作是为全零数组的每一个位置加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) add(i, a[i]);<br></code></pre></td></tr></table></figure><h3 id="42lowbit"><a class="markdownIt-Anchor" href="#42lowbit"></a> 4.2lowbit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43查询query"><a class="markdownIt-Anchor" href="#43查询query"></a> 4.3查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">query</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">query(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>是要求出区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>的和。由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>存储了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">、</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mi mathvariant="normal">、</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">、</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[x - lowbit(x) + 1]、a[x - lowbit(x) + 2]、...、a[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>的和，因此只要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x - lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，并重新执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">query(x - lowbit(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，如此递归直至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i = i - lowbit(i))&#123;<br>        sum += tree[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="44修改add"><a class="markdownIt-Anchor" href="#44修改add"></a> 4.4修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span></h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">add(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>的值加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。在<em>3.索引关系</em>中提到，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的父节点索引为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x + lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，因此通过不断的将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x  + lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，即可修改全部包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>项的节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &lt;= n; i = i + lowbit(i)) tree[i] += y;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随手记0x05</title>
    <link href="/2022/03/19/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x05/"/>
    <url>/2022/03/19/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x05/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这可能是毫无逻辑的一篇…随笔？</p></blockquote><h1 id="唉"><a class="markdownIt-Anchor" href="#唉"></a> 唉</h1><p>今天在写算法题目的时候，创建了一个存放整型数的ArrayList</p><blockquote><p>ArrayList&lt;Integer&gt; nums</p></blockquote><p>因为涉及到了nums中元素的比较操作，debug半个多小时也找不到错误在哪里。</p><p>最后，</p><p>最后发现，我使用了&quot;==&quot;来判断两元素是否相等（可能我默认认为nums中存放的是int而非Integer）…</p><p><strong>以后一定要记得</strong>，一定，一定要用，一定要记得用</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Objects.equals(nums.get(index1), nums.get(index2));<br></code></pre></td></tr></table></figure><blockquote><p>我好愚蠢   😦</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java快速的输入输出</title>
    <link href="/2022/03/01/%E7%A2%8E%E7%89%87&amp;%5B%E8%AF%AD%E8%A8%80,%20Java%5D_Java%E5%BF%AB%E9%80%9F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/01/%E7%A2%8E%E7%89%87&amp;%5B%E8%AF%AD%E8%A8%80,%20Java%5D_Java%E5%BF%AB%E9%80%9F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>鉴于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">System.out.println()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>n</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Scanner</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>输出/输入效率太低了，探索出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>T</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">StreamTokenizer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">BufferedReader</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">PrintWriter</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>这些快速的IO方法。</p><h2 id="streamtokenizer-printwriter"><a class="markdownIt-Anchor" href="#streamtokenizer-printwriter"></a> StreamTokenizer + PrintWriter</h2><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202271050764.png" alt="image-20220227105014727" /></p><p><strong>五次平均355.8ms。</strong></p><h2 id="streamtokenizer-systemout"><a class="markdownIt-Anchor" href="#streamtokenizer-systemout"></a> StreamTokenizer + System.out</h2><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202271053846.png" alt="image-20220227105335810" /></p><p><strong>五次平均827.6ms</strong></p><blockquote><p>PS：感觉这五次结果有点离谱，PrintWriter不应该和System.out差的这么多的吧…毕竟在这五次前，第一次使用这个组合只有531ms。</p><p>还是相信平均相信科学吧…</p></blockquote><h2 id="bufferedreader-systemout"><a class="markdownIt-Anchor" href="#bufferedreader-systemout"></a> BufferedReader + System.out</h2><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202271107728.png" alt="image-20220227110702686" /></p><p><strong>五次平均749.4ms</strong>。但是中间超时了一次就挺离谱的。</p><h2 id="bufferedreader-printwriter"><a class="markdownIt-Anchor" href="#bufferedreader-printwriter"></a> BufferedReader + PrintWriter</h2><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202271427140.png" alt="image-20220227142736082" /></p><p><strong>五次平均768.4ms</strong>。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>总之，StreamTokenizer+PrintWriter的组合应该是最快的。但是StreamTokenizer似乎在处理串的输入上有一些小问题，以后再看看。而PrintWriter的flush方法用起来也有点迷…</p><blockquote><p>以后再把这个坑填上吧。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>碎片</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>花了半天多的时间看了线段树的理论，并造了一个大大的轮子<br />–2022.2.26 18:04</p><p>今天听完了y总版本的线段树。y总的代码风格真的清晰，编码思路与本文的思路略有不同（主要区别在于方法的参数数量较少，原因是使用单独的结构表示了线段树节点，从而在结构中存储了更多信息）。</p><p>如果以后变勤快了的话，再把y总版本加到这里吧。</p><p>​--2022.3.31 17:24</p></blockquote><h2 id="1-背景"><a class="markdownIt-Anchor" href="#1-背景"></a> 1. 背景</h2><p>假设数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>9</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">data = \{1, 6, 3, 4, 8, 2, 9\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mclose">}</span></span></span></span>，当我们需要对数组进行频繁的元素更新、查询某一区间的最大/最小值时，暴力的方法允许在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>时间内完成单点修改与区间查询。</p><p>我们可以使用线段树存储数组元素，此时更新与区间查询的时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p><h2 id="2-概述"><a class="markdownIt-Anchor" href="#2-概述"></a> 2. 概述</h2><p>线段树(segment tree)，是用来存放给定区间内对应信息的一种非常灵活的数据结构。使用数组来存储树型结构，支持区间查询与单点修改。允许在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。</p><h2 id="3-线段树的特点与原理"><a class="markdownIt-Anchor" href="#3-线段树的特点与原理"></a> 3. 线段树的特点与原理</h2><p>线段树是一个平衡二叉树，但不一定是完全二叉树。当数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">data</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的长度是2的整数次幂时，线段树成为满二叉树。同时，这也就决定了线段树可以采用顺序的数组结构存储。</p><p><strong>线段树的节点</strong>：线段树的每个非叶子节点存储了一段区间的信息（如最大值/最小值），每个叶子节点对应数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">data</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的一个元素（叶子节点也可以看作是区间信息，只不过这个区间的左右端点值相等）。</p><p>具体来说，线段树的根节点代表整个数组所在区间的信息，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">data[0: N - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>（含N）所对应的信息。</p><p>将区间均分成两半，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">mid = \frac{N - 1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，根节点的左孩子节点存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">data[0:mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>区间的信息；右孩子节点存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>:</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">data[mid+1:N-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>区间的信息。也正是因为这样的均分策略，最终构造出的树才是平衡二叉树。</p><p><strong>线段树的额外空间</strong>：我们已经知道了线段树的叶子节点存储的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">data</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>中的元素值。如果说平衡二叉树有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个叶子节点的话，那么需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">n</span></span></span></span>的连续空间存储整棵树。</p><blockquote><p>一棵层数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的满二叉树，其第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>层的节点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层的节点<strong>总数</strong>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n - 1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，也就是说，整棵树的节点数大约是最后一层节点数的2倍。<br />若存在第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层，则第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层的节点数也将会是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>层的2倍。r</p><p>由于线段树是平衡二叉树，不一定是满二叉树，因此若有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个叶子节点的话，需要多开辟一层的存储空间，即4倍叶子节点数的额外空间大小。</p></blockquote><h2 id="4-建树"><a class="markdownIt-Anchor" href="#4-建树"></a> 4. 建树</h2><p>线段树的创建是自下而上进行的。一个节点所存储的信息完全由其左右孩子决定。当左右孩子所存储信息确定时，该节点所存储的信息即可确定。</p><p>假如左孩子存储的是区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>的最小值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，右孩子存储的是区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[b, c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>的最小值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，那么父节点存储的区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>的最小值就可以由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>唯一确定。由此自底向上，就可以完成建树了。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight, T[] data)</span></span>&#123;<br>    <span class="hljs-comment">//此时是叶子节点</span><br>    <span class="hljs-keyword">if</span>(dataLeft == dataRight)&#123;<br>        tree[treeNode] = data[dataLeft];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//得到左右子树的顺序索引</span><br>    <span class="hljs-keyword">int</span> left = getLeft(treeNode);<br>    <span class="hljs-keyword">int</span> right = getRight(treeNode);<br>    <span class="hljs-comment">//得到数据的中间索引，如果begin和end很大，相加求和除二的方法可能会溢出。</span><br>    <span class="hljs-keyword">int</span> mid = dataLeft + (dataRight - dataLeft) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//构建左子树</span><br>    buildSegmentTree(left, dataLeft, mid, data);<br>    <span class="hljs-comment">//构建右子树</span><br>    buildSegmentTree(right, mid + <span class="hljs-number">1</span>, dataRight, data);<br>    <span class="hljs-comment">//修改当前节点值</span><br>    tree[treeNode] = merger.merge(tree[left], tree[right]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在构造方法中，可以调用如下语句递归的创建线段树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buildSegmentTree(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length - <span class="hljs-number">1</span>, data);<br></code></pre></td></tr></table></figure><h2 id="5-更新"><a class="markdownIt-Anchor" href="#5-更新"></a> 5. 更新</h2><p>当我们想更新原始数据数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">data</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的某一处的值时，首先要在线段树中确定该值对应的叶子节点索引，之后自底向上的更新路径上的其他节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> dataIndex, T newValue, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span><br></code></pre></td></tr></table></figure><ul><li>treeNode是当前树节点索引——调用更新时应初始化为0</li><li>dataIndex是想要更新的原始数据索引</li><li>newValue是更新后的值</li><li>dataLeft与dataRight是当前树节点treeNode所表示的区间信息的左右端点。</li></ul><p>因此，调用线段树更新操作的对外接口update方法体如下。从根节点treeNode=0处，将原始数据索引为dataIndex的数据更新为newValue。由于根节点所表示的区间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>L</mi><mi>e</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">data[0:dataLen-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，因此后两个参数也就确定了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dataIndex, T newValue)</span></span>&#123;<br>    _update(<span class="hljs-number">0</span>, dataIndex, newValue, <span class="hljs-number">0</span>, dataLen - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于_update方法，方法体如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> dataIndex, T newValue, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dataLeft == dataRight)&#123;<br>        tree[treeNode] = newValue;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> leftChildNode = getLeft(treeNode);<br>    <span class="hljs-keyword">int</span> rightChildNode = getRight(treeNode);<br>    <span class="hljs-keyword">int</span> mid = dataLeft + (dataRight - dataLeft) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(dataIndex &lt;= mid)&#123;<br>        _update(leftChildNode, dataIndex, newValue, dataLeft, mid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        _update(rightChildNode, dataIndex, newValue, mid + <span class="hljs-number">1</span>, dataRight);<br>    &#125;<br>    <span class="hljs-comment">//修改完子树更新当前节点</span><br>    tree[treeNode] = merger.merge(tree[leftChildNode], tree[rightChildNode]);<br>&#125;<br></code></pre></td></tr></table></figure><p>从根节点开始，找到左右孩子所表示的区间信息，若要更新的节点落在左孩子节点所表示的区间内，则以左孩子为根节点递归的调用_update方法。反之则更新右子树。最后修改当前节点的相关信息。</p><p>递归直至dataLeft与dataRight相等终止，即当前节点treeNode是叶子节点，此时寻找到了待更新节点。</p><h2 id="6-查询"><a class="markdownIt-Anchor" href="#6-查询"></a> 6. 查询</h2><p>查询query方法对外的调用接口以及_query的方法的声明如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//query方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> _query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dataLen - <span class="hljs-number">1</span>, dataLeft, dataRight);<br>&#125;<br><br><span class="hljs-comment">//_query方法声明</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> treeLeft, <span class="hljs-keyword">int</span> treeRight, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>treeNode: 线段树的某一节点索引，查询开始时应从根节点0开始。</li><li>treeLeft与treeRight：线段树当前节点所表示的区间左右端点，查询开始时应初始化为0与dataLen - 1.</li><li>dataLeft与dataRight：要查询的区间信息的左右端点。</li></ul><p>由于线段树特殊的区间均分方法，使得查询时出现了四种情况。</p><p>1)如果查询区间与当前节点所表示的区间完全吻合，则可以直接返回当前节点的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(treeLeft == dataLeft &amp;&amp; treeRight == dataRight)&#123;<br>    <span class="hljs-keyword">return</span> tree[treeNode];<br>&#125;<br></code></pre></td></tr></table></figure><p>2)如果查询区间完全位于当前节点左孩子所表示区间中，则以左子树为根节点，递归地调用查询方法。需要注意的是，此时_query方法的参数2与参数3分别为treeLeft、mid，即左孩子所表示的区间左右端点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> leftChildNode = getLeft(treeNode);<br><span class="hljs-keyword">int</span> rightChildNode = getRight(treeNode);<br><span class="hljs-keyword">int</span> mid = treeLeft + (treeRight - treeLeft) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//2.查询区间完全在左子树所表示区间，则去左子树查询</span><br><span class="hljs-keyword">if</span>(dataRight &lt;= mid)&#123;<br>    <span class="hljs-keyword">return</span> _query(leftChildNode, treeLeft, mid, dataLeft, dataRight);<br>&#125;<br></code></pre></td></tr></table></figure><p>3)如果查询区间完全位于当前节点右孩子所表示区间中，则以右子树为根节点，递归调用查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(dataLeft &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> _query(rightChildNode, mid + <span class="hljs-number">1</span>, treeRight, dataLeft, dataRight);<br>&#125;<br></code></pre></td></tr></table></figure><p>4)最后，如果查询区间同时覆盖了左右子树所表示区间的部分，则应该在左子树中查询区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>L</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[dataLeft, mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，在右子树中查询区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid + 1, dataRight]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>，最后将查询到的结果<strong>合并</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T leftValue = _query(leftChildNode, treeLeft, mid, dataLeft, mid);<br>T rightValue = _query(rightChildNode, mid + <span class="hljs-number">1</span>, treeRight, mid + <span class="hljs-number">1</span>, dataRight);<br><span class="hljs-keyword">return</span> merger.merge(leftValue, rightValue);<br></code></pre></td></tr></table></figure><h2 id="7-完整代码"><a class="markdownIt-Anchor" href="#7-完整代码"></a> 7. 完整代码</h2><p>最后，线段树的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.datastructure;<br><br><span class="hljs-keyword">import</span> com.chen.datastructure.SegmentTree.Merger;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> T[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> dataLen;<br>    <span class="hljs-keyword">private</span> Merger&lt;T&gt; merger;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对于自定义数据类型T的线段树，需要给出合并时的动作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 线段树的数据类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Merger</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>        <span class="hljs-function">T <span class="hljs-title">merge</span><span class="hljs-params">(T a, T b)</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(T[] data, Merger&lt;T&gt; merger)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.merger = merger;<br>        <span class="hljs-keyword">this</span>.tree = (T[]) <span class="hljs-keyword">new</span> Object[data.length * <span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">this</span>.dataLen = data.length;<br>        buildSegmentTree(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length - <span class="hljs-number">1</span>, data);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从节点index开始，对原始数据数据构建线段树。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeNode 当前节点索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataLeft 原始数据数组的左端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataRight 原始数据数组的右端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 原始数据数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight, T[] data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(dataLeft == dataRight)&#123;<br>            tree[treeNode] = data[dataLeft];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//得到左右子树的顺序索引</span><br>        <span class="hljs-keyword">int</span> left = getLeft(treeNode);<br>        <span class="hljs-keyword">int</span> right = getRight(treeNode);<br>        <span class="hljs-comment">//得到数据的中间索引，如果begin和end很大，相加求和除二的方法可能会溢出。</span><br>        <span class="hljs-keyword">int</span> mid = dataLeft + (dataRight - dataLeft) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//构建左子树</span><br>        buildSegmentTree(left, dataLeft, mid, data);<br>        <span class="hljs-comment">//构建右子树</span><br>        buildSegmentTree(right, mid + <span class="hljs-number">1</span>, dataRight, data);<br>        <span class="hljs-comment">//修改当前节点值</span><br>        tree[treeNode] = merger.merge(tree[left], tree[right]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对原始索引为dataIndex的数据值更改。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataIndex 要更改的原始数据索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> newValue 更改后的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dataIndex, T newValue)</span></span>&#123;<br>        _update(<span class="hljs-number">0</span>, dataIndex, newValue, <span class="hljs-number">0</span>, dataLen - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部修改逻辑</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeNode 当前节点的索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataIndex 要修改的数据的原始索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> newValue 要修改的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataLeft 数据区间左端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataRight 数据区间右端点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> dataIndex, T newValue, <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(dataLeft == dataRight)&#123;<br>            tree[treeNode] = newValue;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> leftChildNode = getLeft(treeNode);<br>        <span class="hljs-keyword">int</span> rightChildNode = getRight(treeNode);<br>        <span class="hljs-keyword">int</span> mid = dataLeft + (dataRight - dataLeft) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(dataIndex &lt;= mid)&#123;<br>            _update(leftChildNode, dataIndex, newValue, dataLeft, mid);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _update(rightChildNode, dataIndex, newValue, mid + <span class="hljs-number">1</span>, dataRight);<br>        &#125;<br>        <span class="hljs-comment">//修改完子树更新当前节点</span><br>        tree[treeNode] = merger.merge(tree[leftChildNode], tree[rightChildNode]);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线段树的区间查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataLeft 查询区间左端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataRight 查询区间右端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> _query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dataLen - <span class="hljs-number">1</span>, dataLeft, dataRight);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部的区间查询逻辑</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeNode 当前treeNode的索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeLeft 当前treeNode所表示区间的左端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeRight 当前treeNode所表示区间的右端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataLeft 查询区间左端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataRight 查询区间的右端点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeNode, <span class="hljs-keyword">int</span> treeLeft, <span class="hljs-keyword">int</span> treeRight,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">int</span> dataLeft, <span class="hljs-keyword">int</span> dataRight)</span></span>&#123;<br>        <span class="hljs-comment">//1.查询区间完全与当前node节点所表示区间重合</span><br>        <span class="hljs-keyword">if</span>(treeLeft == dataLeft &amp;&amp; treeRight == dataRight)&#123;<br>            <span class="hljs-keyword">return</span> tree[treeNode];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> leftChildNode = getLeft(treeNode);<br>        <span class="hljs-keyword">int</span> rightChildNode = getRight(treeNode);<br>        <span class="hljs-keyword">int</span> mid = treeLeft + (treeRight - treeLeft) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//2.查询区间完全在左子树所表示区间，则去左子树查询</span><br>        <span class="hljs-keyword">if</span>(dataRight &lt;= mid)&#123;<br>            <span class="hljs-keyword">return</span> _query(leftChildNode, treeLeft, mid, dataLeft, dataRight);<br>        &#125;<br>        <span class="hljs-comment">//3.查询区间完全在右子树所表示区间，则去右子树查询</span><br>        <span class="hljs-keyword">if</span>(dataLeft &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> _query(rightChildNode, mid + <span class="hljs-number">1</span>, treeRight, dataLeft, dataRight);<br>        &#125;<br>        <span class="hljs-comment">//4.查询区间一般在左子树，一半在右子树</span><br>        <span class="hljs-comment">//此时，应该去左子树查询dataLeft至左子树所表示区间的右端点——mid，去右子树查询右子树所表示区间的左端点——mid+1至dataRight</span><br>        <span class="hljs-comment">//并merge</span><br>        T leftValue = _query(leftChildNode, treeLeft, mid, dataLeft, mid);<br>        T rightValue = _query(rightChildNode, mid + <span class="hljs-number">1</span>, treeRight, mid + <span class="hljs-number">1</span>, dataRight);<br>        <span class="hljs-keyword">return</span> merger.merge(leftValue, rightValue);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(T num: tree)&#123;<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随手记0x04</title>
    <link href="/2022/02/24/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x04/"/>
    <url>/2022/02/24/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x04/</url>
    
    <content type="html"><![CDATA[<h2 id="注解annotation"><a class="markdownIt-Anchor" href="#注解annotation"></a> 注解(Annotation)</h2><p>从JDK5.0开始，Java增加了注解。</p><p>注解其实就是代码里的特殊标记。这些标记可以在编译、类加载、运行时被读取，并执行相应处理。</p><ul><li><p>@Override: 在编译阶段就可以检查一个方法是否正确继承自其父类，如果被Override修饰的重写方法并非继承自父类，则编译阶段会报错。</p></li><li><p>@Deprecated：被@Deprecated修饰的方法在使用时会出现提示：过时的方法，建议不要使用</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202204011112313.png" alt="image-20220401111230261" /></p></li><li><p>@SuppressWarnings：抑制编译器警告，可以添加具体的警告类型参数。</p><p>在未添加注解时，警告变量y未曾使用过。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202204011115831.png" alt="image-20220401111518793" /></p><p>当我们添加注解后，可以看到编译器对上述警告视而不见。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202204011121257.png" alt="image-20220401112159226" /></p></li></ul><hr /><blockquote><p>这里坑好深，日后再填吧。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随手记0x03</title>
    <link href="/2022/02/16/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x03/"/>
    <url>/2022/02/16/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x03/</url>
    
    <content type="html"><![CDATA[<p>当我们想要设计下面这样的图案时，单纯的将div转成块元素并增加padding或者margin是很难通过定位去对齐的。</p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202141950273.png" alt="image-20220214195030170" style="zoom:50%;" /><p>不过鉴于CSS中可以很简单的margin:0 auto实现居中，因此可以设计前景与背景。背景不需要margin与padding，而前景则可以通过margin:0 auto实现在背景div中的居中。</p><blockquote><p>太妙了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极其敷衍的前端入门(version：两天速成)</title>
    <link href="/2022/02/14/%5B%E8%AF%AD%E8%A8%80,%20%E5%89%8D%E7%AB%AF%5D_%E6%9E%81%E5%85%B6%E6%95%B7%E8%A1%8D%E7%9A%84%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8(version%EF%BC%9A%E4%B8%A4%E5%A4%A9%E9%80%9F%E6%88%90)/"/>
    <url>/2022/02/14/%5B%E8%AF%AD%E8%A8%80,%20%E5%89%8D%E7%AB%AF%5D_%E6%9E%81%E5%85%B6%E6%95%B7%E8%A1%8D%E7%9A%84%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8(version%EF%BC%9A%E4%B8%A4%E5%A4%A9%E9%80%9F%E6%88%90)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hyper Text Markup Language -----HTML</p></blockquote><blockquote><p>曾经网页需要flash实现一些功能，但是html5已经完全可以做到了</p></blockquote><p>W3C标准包括</p><ul><li>结构化标准语言——HTML、XML</li><li>表现标准语言——CSS</li><li>行为标准——DOM、ECMAScript</li></ul><h1 id="1html"><a class="markdownIt-Anchor" href="#1html"></a> 1.HTML</h1><h2 id="11网页基本信息"><a class="markdownIt-Anchor" href="#11网页基本信息"></a> 1…1网页基本信息</h2><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- DOCTYPE：告诉浏览器，我们使用的规范--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- head tag代表网页头部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- meta是描述性标签，描述网站的一些信息--&gt;</span><br>    <span class="hljs-comment">&lt;!-- meta一般用来做SEO--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Chen<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-comment">&lt;!-- body tag代表网页主体--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>Hello, World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="12行内元素和块元素"><a class="markdownIt-Anchor" href="#12行内元素和块元素"></a> 1.2行内元素和块元素</h2><p>块元素：无论内容多少，该元素独占一行，如p、h1~h6</p><p>行内元素：通俗点说不会换行…，如a、strong、em</p><h2 id="13基本标签"><a class="markdownIt-Anchor" href="#13基本标签"></a> 1.3基本标签</h2><ul><li><p>p：段落</p></li><li><p>br：换行</p></li><li><p>h1~h6：六级标题</p></li><li><p>strong：粗体</p></li><li><p>em：斜体</p></li><li><p>&amp;nbsp：空格</p><blockquote><p>这应该算特殊符号，不算tag</p></blockquote></li><li><p>img：图像标签</p><blockquote><p>src、alt、title、width、height属性</p></blockquote></li><li><p>a：链接标签</p><blockquote><p>href target</p></blockquote></li></ul><h2 id="14列表"><a class="markdownIt-Anchor" href="#14列表"></a> 1.4列表</h2><ul><li><p>有序列表ol</p></li><li><p>无序列表ul</p><blockquote><p>有序列表和无序列表的表项均用li标签</p></blockquote></li><li><p>自定义列表dl</p><blockquote><p>dt标签确定题目，dd标签确定表项</p></blockquote></li></ul><h2 id="15表格"><a class="markdownIt-Anchor" href="#15表格"></a> 1.5表格</h2><h2 id="16视频元素与音频元素"><a class="markdownIt-Anchor" href="#16视频元素与音频元素"></a> 1.6视频元素与音频元素</h2><h2 id="17iframe内联框架"><a class="markdownIt-Anchor" href="#17iframe内联框架"></a> 1.7iframe内联框架</h2><blockquote><p>好神奇！</p></blockquote><h2 id="18表单"><a class="markdownIt-Anchor" href="#18表单"></a> 1.8表单</h2><blockquote><p>重点</p></blockquote><h1 id="2css"><a class="markdownIt-Anchor" href="#2css"></a> 2.CSS</h1><h2 id="21选择器"><a class="markdownIt-Anchor" href="#21选择器"></a> 2.1选择器</h2><blockquote><p>选择页面上的某一个后者某一类元素</p></blockquote><h3 id="211基本选择器"><a class="markdownIt-Anchor" href="#211基本选择器"></a> 2.1.1基本选择器</h3><p>当一个标签的样式同时被标签选择器、类选择器、id选择器生效时，优先级为：id选择器&gt;类选择器&gt;标签选择器。</p><p><strong>标签选择器</strong>会选中页面的所有标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#a3ffad</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>;</span><br><span class="css">        &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样会改变所有的h1与p标签</p><p><strong>类选择器</strong>则会改变目标类的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.tag</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>tag是一个标签所属的类，可以自定义设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span><br>        Chen<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>id选择器</strong>则会对全局唯一的目标id产生效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#tag</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ... --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span><br>        Chen<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="212层次选择器"><a class="markdownIt-Anchor" href="#212层次选择器"></a> 2.1.2层次选择器</h3><ul><li>后代选择器</li><li>子选择器</li><li>相邻兄弟选择器</li><li>通用选择器</li></ul><blockquote><p>以上均顾名思义…</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*后代选择器，对body的所有p标签生效*/</span><br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-comment">/*子选择器，对body下的直接的p标签生效*/</span><br><span class="hljs-selector-tag">body</span> &gt; <span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-comment">/*相邻兄弟选择器，选择class为active的p标签的相邻的右兄弟p标签*/</span><br><span class="hljs-selector-class">.active</span> + <span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">background</span>: brown;<br>&#125;<br><br><span class="hljs-comment">/*通用选择器，选择class为active的p标签及其所有的右兄弟p标签*/</span><br><span class="hljs-selector-class">.active</span> ~ <span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="213结构伪类选择器"><a class="markdownIt-Anchor" href="#213结构伪类选择器"></a> 2.1.3结构伪类选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*ul的第一个子元素*/</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child&#123;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br><span class="hljs-comment">/*ul的最后一个子元素*/</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;<br>    <span class="hljs-attribute">background</span>: antiquewhite;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="214属性选择器"><a class="markdownIt-Anchor" href="#214属性选择器"></a> 2.1.4属性选择器</h3><p>结合了id与class属性。</p><p>标签[属性]</p><p>标签[属性=值]</p><p>其中，=可以替换为</p><ul><li>*=通配符</li><li>^=    开头</li><li>$=    结尾</li></ul><h2 id="22网页元素美化"><a class="markdownIt-Anchor" href="#22网页元素美化"></a> 2.2网页元素美化</h2><h3 id="css字体样式"><a class="markdownIt-Anchor" href="#css字体样式"></a> CSS字体样式</h3><ul><li><p>span标签</p></li><li><p>文本样式</p><blockquote><p>font-family、font-size、font-weight</p></blockquote></li></ul><h3 id="列表样式"><a class="markdownIt-Anchor" href="#列表样式"></a> 列表样式</h3><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><h3 id="渐变"><a class="markdownIt-Anchor" href="#渐变"></a> 渐变</h3><h2 id="23盒子模型"><a class="markdownIt-Anchor" href="#23盒子模型"></a> 2.3盒子模型</h2><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202202120940174.png" alt="image-20220212094021085" /></p><ul><li>margin</li><li>border</li><li>padding</li></ul><h2 id="24浮动"><a class="markdownIt-Anchor" href="#24浮动"></a> 2.4浮动</h2><h2 id="25定位"><a class="markdownIt-Anchor" href="#25定位"></a> 2.5定位</h2><h2 id="26层级"><a class="markdownIt-Anchor" href="#26层级"></a> 2.6层级</h2><blockquote><p>z-index</p></blockquote><h1 id="3javascript"><a class="markdownIt-Anchor" href="#3javascript"></a> 3.JavaScript</h1><p>外部导入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="31运算符"><a class="markdownIt-Anchor" href="#31运算符"></a> 3.1运算符</h2><ul><li><p>逻辑运算</p></li><li><p>比较运算</p><blockquote><p>=</p><p>== 等于：类型不一样，值一样为true</p><p>=== 绝对等于：类型一样，值一样为true</p><p>例：</p><p>1 == “1”   true</p><p>1 === “1” false</p><blockquote><p>这是JS的缺陷，坚持不要使用==</p></blockquote></blockquote></li></ul><h2 id="32严格检查模式"><a class="markdownIt-Anchor" href="#32严格检查模式"></a> 3.2严格检查模式</h2><p>在代码的开头加入单独的一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br></code></pre></td></tr></table></figure><p>就进入严格检查模式，以防止JS的随意出现的问题。</p><h2 id="33变量定义"><a class="markdownIt-Anchor" href="#33变量定义"></a> 3.3变量定义</h2><p>默认所有的全局变量，都被绑定在全局对象window上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>alert(x);<br>alert(<span class="hljs-built_in">window</span>.x);<br></code></pre></td></tr></table></figure><p>实际上，即使是alert也是绑定在window上的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-built_in">window</span>.alert(x);<br><span class="hljs-built_in">window</span>.alert(<span class="hljs-built_in">window</span>.x);<br></code></pre></td></tr></table></figure><p>var定义会有一些局部作用域冲突问题，所以建议使用<em>let</em>去<strong>定义局部作用域</strong>的变量。</p><h2 id="34数据类型"><a class="markdownIt-Anchor" href="#34数据类型"></a> 3.4数据类型</h2><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><ul><li>字符串使用单引号或者双引号</li><li>也可以使用`(波浪线对应的点)构造多行字符串</li><li>模板字符串</li></ul><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br></code></pre></td></tr></table></figure><p>可以给arr.length赋值，数组大小会发生变化。赋值过小则会丢失元素</p><ul><li><p>slice()：截取arr的一部分，返回新数组，切片操作。</p></li><li><p>push(), pop()</p></li><li><p>unshift(), shift()，与push pop相反，对头部元素操作。</p></li></ul><h3 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h3><p>js的对象类似json的格式…好离谱。</p><p>使用不存在的对象属性不会报错，只会出现undefined。</p><p>可以使用delete obj.attribute删除对象属性</p><p>也可以直接添加属性，类似python</p><h3 id="map与setes6新特性"><a class="markdownIt-Anchor" href="#map与setes6新特性"></a> Map与Set：ES6新特性</h3><h2 id="35函数"><a class="markdownIt-Anchor" href="#35函数"></a> 3.5函数</h2><p>如果没有执行return，函数执行完也会返回结果，结果是undefined</p><p>不过js里有两种定义方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAbs</span>(<span class="hljs-params">x</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> -x;<br>&#125;<br><br><span class="hljs-keyword">var</span> myAbs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> -x;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用时参数的数量是任意的…甚至可以不传</p><blockquote><p>麻了</p></blockquote><ul><li>可以通过typeof对传入参数的类型进行检查</li><li>可以通过arguments遍历传入的所有参数。auguments是一个数组</li><li>也可以通过增加*…rest*参数，函数体内可以通过rest数组遍历所有未定义的参数。</li></ul><h2 id="36apply"><a class="markdownIt-Anchor" href="#36apply"></a> 3.6apply</h2><p>js中可以控制this的指向。</p><h2 id="37内部对象"><a class="markdownIt-Anchor" href="#37内部对象"></a> 3.7内部对象</h2><h3 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h3><h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3><h3 id="ajax"><a class="markdownIt-Anchor" href="#ajax"></a> Ajax</h3><h2 id="38操作bom对象"><a class="markdownIt-Anchor" href="#38操作bom对象"></a> 3.8操作BOM对象</h2><blockquote><p>BOM：浏览器对象模型</p></blockquote><p>window screen document等</p><h2 id="39操作dom对象"><a class="markdownIt-Anchor" href="#39操作dom对象"></a> 3.9操作DOM对象</h2><blockquote><p>DOM：文档对象模型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById<br><span class="hljs-built_in">document</span>.createElement<br></code></pre></td></tr></table></figure><h2 id="310jquery"><a class="markdownIt-Anchor" href="#310jquery"></a> 3.10jQuery</h2><p>jQuery是一个库，里面存在大量的javascript函数</p>$(selector).action;<blockquote><p>jQuery好舒服！</p></blockquote><h3 id="selector"><a class="markdownIt-Anchor" href="#selector"></a> selector</h3><p>css有的，jQuery都有。</p><h3 id="action"><a class="markdownIt-Anchor" href="#action"></a> action</h3><p>各种事件，没啥好说的</p><p>一般的js代码都要求在网页元素加载完成后执行。将js代码写到下面的大括号内即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;)<br><br><span class="hljs-comment">//简略写法</span><br><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随手记0x02</title>
    <link href="/2022/02/14/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x02/"/>
    <url>/2022/02/14/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x02/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串的hashcode"><a class="markdownIt-Anchor" href="#字符串的hashcode"></a> 字符串的hashCode</h2><p>String类型，只要值相同，那么hashCode一定相同。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> length = value.length &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        h = <span class="hljs-number">31</span> * h + getChar(value, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是String hashCode的源码，其中value是String类内部维护的字符数组。</p><p>可以看出，字符数组的值一样，则hashCode就相同。</p><p>即equals方法相同的两个String，hashCode一定相同。</p><blockquote><p>所以这里应用了散列？</p></blockquote><h2 id="objectshash方法"><a class="markdownIt-Anchor" href="#objectshash方法"></a> Objects.hash()方法</h2><p>当我们自定义类，想要重写hashCode方法时，可以通过Objects.hash()来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    Employee(String name, <span class="hljs-keyword">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// return name.hashCode() + age;</span><br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<span class="hljs-comment">//这里就很方便了</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(o == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Employee)&#123;<br>            Employee e = (Employee) o;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(e.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == e.age;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        rturn name + <span class="hljs-string">&quot; &quot;</span> + age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随手记0x01</title>
    <link href="/2022/02/03/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x01/"/>
    <url>/2022/02/03/%E9%9A%8F%E6%89%8B%E8%AE%B0_%E9%9A%8F%E6%89%8B%E8%AE%B00x01/</url>
    
    <content type="html"><![CDATA[<p>在求解质因数时，通常采用从1至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{number}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.10777999999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span></span>的循环来判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">number</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>的质因数有哪些。</p><p>而在大多数语言的数学库中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sqrt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span>计算开方的效率是比较慢的。</p><p>因此，不妨采用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">i * i &lt; numbeer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>来替代<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><msqrt><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">i &lt; \sqrt{number}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.10777999999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span></span>…</p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java比较器</title>
    <link href="/2022/01/28/%E7%A2%8E%E7%89%87&amp;%5B%E8%AF%AD%E8%A8%80,%20Java%5D_Java%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <url>/2022/01/28/%E7%A2%8E%E7%89%87&amp;%5B%E8%AF%AD%E8%A8%80,%20Java%5D_Java%E6%AF%94%E8%BE%83%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Java实现对象排序的方式有两种，涉及到两个接口</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><p>自然排序的实现思路类似于C++的仿函数，当需要对自定义类的对象集合排序时，可以采用自然排序Comparable接口。</p><p>定制排序是对已经实现自然排序的类且想按照新的任意规则排序时，在排序时传入Comparator接口对象，从而实现。</p><blockquote><p>PS: Java的类库思路真的好整齐。</p></blockquote><h2 id="comparable接口"><a class="markdownIt-Anchor" href="#comparable接口"></a> Comparable接口</h2><p>实现Comparable接口，重写compareTo()方法。思路及方法与C++仿函数类似。</p><blockquote><p>注意，并不强求重写hashCode与equals方法，但对于某些数据结构（TreeSet等），为了保证排序结果与内部排序结果的一致性，通常选择重写。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.age != o.age)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - o.age;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(o.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="comparator接口"><a class="markdownIt-Anchor" href="#comparator接口"></a> Comparator接口</h2><p>当元素类型没有实现Comparable接口而又不方便修改代码，或者实现了Comparable接口但是排序规则需要暂时修改时，使用Comparator接口，并重写compare方法。</p><hr /><p>Arrays.sort()方法，可以直接传入对象数组，此时按照自然排序即comparable接口提供的方法去从小到大排序；也可以传入实现了Comparator接口的对象，使得对象数组按照Comparator接口提供的方法进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] persons = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">4</span>];<br>        persons[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-number">18</span>);<br>        persons[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">19</span>);<br>        persons[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lucy&quot;</span>, <span class="hljs-number">17</span>);<br>        persons[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-number">18</span>);<br>        Arrays.sort(persons);<br>        System.out.println(Arrays.toString(persons));<br><br>        Arrays.sort(persons, <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span></span>&#123;<br>                <span class="hljs-keyword">if</span>(p1.getAge() != p2.getAge())<br>                    <span class="hljs-keyword">return</span> -(p1.getAge() - p2.getAge());<br>                <span class="hljs-keyword">return</span> -p1.getName().compareTo(p2.getName());<br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(persons));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.age != o.age)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - o.age;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(o.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>通过Comparable接口，实现了从小到大排序；通过匿名类实现了Comparator接口排序。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>碎片</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混淆矩阵与ROC曲线</title>
    <link href="/2022/01/25/%E7%A2%8E%E7%89%87_%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%8EROC%E6%9B%B2%E7%BA%BF/"/>
    <url>/2022/01/25/%E7%A2%8E%E7%89%87_%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%8EROC%E6%9B%B2%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="confusion-matrix混淆矩阵"><a class="markdownIt-Anchor" href="#confusion-matrix混淆矩阵"></a> <strong>Confusion Matrix</strong>（混淆矩阵）</h2><p>对于二分类问题，我们将样本根据其真实类别与学习器预测类别的组合划分为ture positive(真正例)、false positive(假正例)、true negative(真反例)、false negative(假反例)。从而构建如下所示的Confusion Matrix.</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201210939758.png" alt="image-20220121093854643" /></p><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>P</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">Accuracy = \frac{(TP + TN)}{(P + N)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>Ture Positive Rate:  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TPR = \frac{TP}{TP+FN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>False Positive Rate:  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>N</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TNR=\frac{TN}{TN+FP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><blockquote><p>可以看出，TPR与TNR均是观察混淆矩阵的某一列</p></blockquote></li></ul><h2 id="roc曲线"><a class="markdownIt-Anchor" href="#roc曲线"></a> <strong>ROC曲线</strong></h2><blockquote><p>ROC全称是“受试者工作特征”(Receiver Operating Characteristic)曲线，源于二战中用于敌机检测的雷达信号分析技术。</p></blockquote><p>很多学习器会为样本产生一个实值或预测概率，然后将这个预测值与threshold进行比较。大于阈值则为正类，反之为负类。</p><p>ROC曲线以TPR为纵轴，FPR为横轴。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201211001862.png" alt="image-20220121100115815" /></p><ul><li>对角线为Random guess，理论上</li><li>threshold太低，所有样本被判断为true positive，ROC曲线为左上角点</li><li>threshold太高，所有样本被判断为true negative，ROC曲线为左下角点。</li><li>当threshold变化时，最终得到模型的TPR、FPR在曲线上滑动</li></ul><p>根据有限个测试样例可以绘制不光滑的ROC曲线。即不断改变threshold，最终得到了一个“梯形”图。</p><p>进行学习器比较时，若一个学习器的ROC曲线被另一个学习器曲线完全“包住”，则可断言后者性能由于前者。</p><p>若两个学习器的ROC曲线发生交叉，则难以一般性断言性能优劣。此时通过AUC(Area Under ROC Curve)来判断。</p>]]></content>
    
    
    <categories>
      
      <category>碎片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2022/01/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80_Java_Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/01/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80_Java_Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>相比于C++ STL来说，Java的集合架构给我的感觉是更有条理。连源码看起来都很好看（还没到深入源码的地步），感觉自己的编码风格都要受到影响了   😦</p><p>先粗略过一遍吧，底层的结构等读完核心技术再来补充。</p></blockquote><h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h1><p>与C++的STL的6大组件理念类似，Java的集合框架都包含如下内容：</p><ul><li>接口：如Collection、List、Set、Map等</li><li>实现类：实现了特定接口的类。如ArrayList、LinkedList、HashSet、HaseMap等。</li><li>算法：主要由Collections工具类实现。类似STL种头文件alghorithm的作用。</li></ul><p>Java中有两大类接口Collection，Map。接口之间的关系及其实现类的类图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201211508789.png" alt="img" /></p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201211509584.png" alt="image-20220121150955536" /></p><h1 id="二-collection接口"><a class="markdownIt-Anchor" href="#二-collection接口"></a> 二、Collection接口</h1><p>Collection接口没有直接实现的子类。但其子接口List或者Set有直接实现类。</p><p>Collection接口规定了一些简单的方法，并没有指明具体的存储结构，因此不提供取元素等方法(如get()、indexOf())</p><h2 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h2><blockquote><ul><li><p>add remove contains size isEmpty clear</p></li><li><p>addAll containsAll removeAll</p><blockquote><p>*All方法的参数必须是实现了Collection接口的对象。</p></blockquote></li></ul></blockquote><h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2><p>Collection接口继承自Iterable接口，所以可以通过迭代器Iterator遍历。</p><p>迭代器有hasNext()与next()方法</p><blockquote><p>顾名思义</p><p>不过要注意的是，调用next()前记得调用hasNext()方法，否则可能会抛出NoSuchElementException异常</p></blockquote><p>通过调用Collection接口的iterator()方法，获得集合迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">5</span>);<br><br>    Iterator iterator = list.iterator();<br>    <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>        System.out.println(iterator.next());<br>    &#125;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以通过增强for循环去遍历。</p><h1 id="三-list接口"><a class="markdownIt-Anchor" href="#三-list接口"></a> 三、List接口</h1><p>List接口的实现类有一些特点：</p><ul><li>集合中元素有序（添加顺序与取出顺序一致）。</li><li>可以存在重复元素。</li><li>每个元素都有对应的顺序索引，可以通过get方法返回</li></ul><h2 id="常用方法-2"><a class="markdownIt-Anchor" href="#常用方法-2"></a> 常用方法</h2><p>除Collection提供的方法外(有一些重载，如add()，由于指明了具体的存储结构，因此可以在指定index处add了)，还有一些新增方法：</p><ul><li><p>get()</p></li><li><p>indexOf()、lastIndexOf()</p><blockquote><p>c++没有欸</p></blockquote></li></ul><h2 id="遍历-2"><a class="markdownIt-Anchor" href="#遍历-2"></a> 遍历</h2><ul><li>增强for</li><li>由于List是Collection的子接口，因此可以使用Iterator遍历</li><li>通过索引</li></ul><h2 id="三个主要的实现类"><a class="markdownIt-Anchor" href="#三个主要的实现类"></a> 三个主要的实现类</h2><h3 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h3><ul><li><p>基于数组实现</p></li><li><p>存储元素的数组为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br></code></pre></td></tr></table></figure><blockquote><p>transient修饰词以后再看吧</p></blockquote></li><li><p>线程不安全</p></li><li><p>扩容机制与STL的Vector有一点不同，ArrayList每次扩容为原容量1.5倍</p></li></ul><h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h3><ul><li>基于数组实现</li><li>线程安全，方法使用synchronized修饰</li><li>扩容机制与STL的Vector一致，2倍扩容。</li></ul><h3 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h3><ul><li>底层实现了双向链表和双端队列的特点</li><li>线程不安全</li></ul><p>这里和数据结构课上手撕的基于数组的顺序表与基于链式结构的顺序表类似，分别对应着ArrayList与LinkedList类。</p><p>可以根据插入/删除操作的频繁程度来决定使用哪一个类作为List接口的实现类。</p><p>Vector与ArrayList区别在于前者是线程安全的，因此必然会损失一定的时间效率。算法题目中几乎不用Vector类。</p><h1 id="四-set接口"><a class="markdownIt-Anchor" href="#四-set接口"></a> 四、Set接口</h1><p>Set接口的实现类的特点：</p><ul><li><p>元素无序，不能通过索引访问</p></li><li><p>不允许有重复元素</p><blockquote><p>因此对于自定义类型，需要重写hashCode与equal方法</p><p>这点很重要！</p></blockquote></li><li><p>可以通过迭代器遍历</p></li></ul><h2 id="常用方法-3"><a class="markdownIt-Anchor" href="#常用方法-3"></a> 常用方法</h2><ul><li>Set接口是Collection接口的子接口。</li></ul><h2 id="实现类"><a class="markdownIt-Anchor" href="#实现类"></a> 实现类：</h2><h3 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h3><p>有趣的是，若我们执行下面的语句构造一个HashSet对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; s = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br></code></pre></td></tr></table></figure><p>在HashSet的构造方法源码中，实际上构造了一个HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以通过add方法的返回值判断要添加的元素是否已经存在于HashSet中了</li><li>与C++ unordered_set类似</li></ul><h3 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h3><ul><li>与C++ set类似</li><li>有序。</li></ul><h3 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h3><ul><li>是HashSet的子类</li><li>底层是一个LinkedHashMap，额外维护了一个数组与双向链表</li><li>从而使元素看起来是以插入顺序保存的。</li></ul><h1 id="五-map接口"><a class="markdownIt-Anchor" href="#五-map接口"></a> 五、Map接口</h1><p>实现了Map接口的实现类均维护了键值对的映射关系。</p><h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h3><ul><li>线程不安全</li><li>底层基于红黑树</li></ul><h3 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h3><h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h3><ul><li>线程安全</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《软件工程》课程总结</title>
    <link href="/2022/01/10/CUMT%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93_%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/10/CUMT%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93_%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一-软件工程概述"><a class="markdownIt-Anchor" href="#一-软件工程概述"></a> 一、软件工程概述</h2><p>软件工程是计算机软件开发的过程、方法和工具的学科。我们的软件工程课程主要讲了如下内容</p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201081430207-软件工程概述.png" style="zoom:50%;" /><h3 id="1-软件生命周期"><a class="markdownIt-Anchor" href="#1-软件生命周期"></a> 1. 软件生命周期</h3><p>软件生命周期是从软件目标的提出、定义、开发、维护，直到最终被丢弃的整个过程。</p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201081434036-软件生命周期.png" style="zoom:50%;" /><p>比较有趣的是，大部分人觉得软件中大部分错误是编码错误，但据统计，设计错误占软件错误的63%，<strong>编码仅占37%</strong>。</p><h3 id="2-软件开发模型"><a class="markdownIt-Anchor" href="#2-软件开发模型"></a> 2. 软件开发模型</h3><p>软件开发模型是对软件过程的建模，需要确定任务及执行顺序，保证质量和适应需求变化。</p><p>常见的软件开发模型：</p><ul><li>瀑布模型</li><li>原型模型</li><li>增量模型</li><li>螺旋模型</li></ul><h2 id="二-软件开发的计划时期"><a class="markdownIt-Anchor" href="#二-软件开发的计划时期"></a> 二、软件开发的计划时期</h2><p>通常，在计划时期，我们要完成问题定义以及可行性研究分析。</p><h3 id="1-问题定义"><a class="markdownIt-Anchor" href="#1-问题定义"></a> 1. 问题定义</h3><h3 id="2-可行性研究"><a class="markdownIt-Anchor" href="#2-可行性研究"></a> 2. 可行性研究</h3><p>在最短时间内，花费最小代价，确定定义的项目是不是<strong>可能实现</strong>和<strong>值得开发</strong>的。</p><ul><li>经济可行性</li><li>技术可行性</li><li>运行可行性</li><li>法律可行性</li></ul><h2 id="三-需求分析"><a class="markdownIt-Anchor" href="#三-需求分析"></a> 三、需求分析</h2><p>在需求分析阶段，我们要建立目标系统的逻辑模型，并形成《软件需求规格说明》。</p><blockquote><p>目标系统的逻辑模型即反复与用户交流，调查“系统必须要做什么”，建立原型系统。</p><p>数据流图、数据字典、加工处理</p></blockquote><h3 id="1-数据流图data-flow-diagram"><a class="markdownIt-Anchor" href="#1-数据流图data-flow-diagram"></a> 1. 数据流图(Data Flow Diagram)</h3><p>顶层DFD是系统的基本逻辑模型，包含<strong>一个</strong>加工处理和若干输入输出流</p><blockquote><p>顶层DFD图中不应该出现外部存储</p></blockquote><p>分层细化DFD的原则：</p><ul><li>父子图平衡：将一个加工处理分解为一系列子加工时，分解前后的输入输出数据流必须相同。</li><li>区分全局文件与外部项</li></ul><p>DFD图绘制规则：</p><ul><li>顶层数据流图<u><strong>不要</strong></u>出现数据存储</li><li>数据存储之间、外部实体之间、数据存储与外部实体之间<u><strong>不能</strong></u>出现数据流</li><li>数据流是<u><strong>单向</strong></u>的，不能出现双向箭头。</li><li>任何加工都必须有输入和输出数据流</li></ul><h3 id="2-数据字典"><a class="markdownIt-Anchor" href="#2-数据字典"></a> 2. 数据字典</h3><p>包括数据元素（数据项）、数据流、数据存储。</p><h4 id="数据流"><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h4><p>对DFD图中数据流的描述。</p><blockquote><p>数据流名：</p><p>别名：</p><p>组成：</p><p>备注：</p></blockquote><h4 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h4><p>对DFD图中的数据存储的描述</p><blockquote><p>文件名：</p><p>组成：</p><p>组织：</p><blockquote><p>按某一字段，某种顺序排列</p></blockquote><p>备注：</p></blockquote><h4 id="数据元素"><a class="markdownIt-Anchor" href="#数据元素"></a> 数据元素</h4><p>数据元素是对数据流、数据存储中的字典条目（组成）的解释</p><blockquote><p>数据项名：</p><p>别名：</p><p>取值：</p><p>备注：</p></blockquote><h3 id="3-加工逻辑"><a class="markdownIt-Anchor" href="#3-加工逻辑"></a> 3. 加工逻辑</h3><p>加工逻辑用来描述DFD中每个加工能够“做什么”。</p><p>通常使用<u>结构化语言</u>、<u>判定表</u>、<u>判定树</u>、<u>IPO图</u>来描述加工逻辑。</p><h3 id="4-结构化分析方法structured-analysis"><a class="markdownIt-Anchor" href="#4-结构化分析方法structured-analysis"></a> 4. 结构化分析方法(Structured Analysis)</h3><p>在20世纪70年代中期，提出来了一种成为结构化设计(<em>structured design</em>)的软件设计技术。而在70年代后期，又有人提出了与SD配套的结构化分析(SA)技术，合称为<u><strong>结构化分析与设计方法</strong></u>。</p><p>SA的指导思想是自顶向下、逐步分解（对应于我们DFD图的绘制步骤），SA方法的步骤有：</p><ul><li>分层细化DFD图</li><li>定义数据字典</li><li>定义加工逻辑</li></ul><h2 id="四-概要设计"><a class="markdownIt-Anchor" href="#四-概要设计"></a> 四、概要设计</h2><p>在需求分析阶段得出了DFD图、数据字典之后，从需求分析阶段的结果除法，概要设计进行<u><strong>软件结构设计</strong></u>与**<u>数据设计</u>**，编写《概要设计说明书》。</p><ul><li>软件结构设计：是概要设计的主要工作，分析系统由哪些模块组成，优化模块间的关系。</li><li>数据设计：将需求分析阶段创建的数据字典，转换为实现系统所需的数据结构（ER图等）。</li></ul><h3 id="1-软件结构设计"><a class="markdownIt-Anchor" href="#1-软件结构设计"></a> 1. 软件结构设计</h3><p>通过软件结构设计，建立软件良好的模块结构，确定模块、模块间的关系</p><h4 id="内聚与耦合"><a class="markdownIt-Anchor" href="#内聚与耦合"></a> 内聚与耦合</h4><p>对于软件结构，有这么一句话：宁要塔型，不要饼型，提倡翁型</p><ul><li><p>内聚：模块内部各成分之间的关联越高，即内聚越强</p><blockquote><p>功能内聚、顺序内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。</p><p>内聚程度依次降低</p></blockquote></li><li><p>耦合：模块之间的联系越小，即耦合越松散</p><blockquote><p>非直接耦合、数据耦合、特征耦合、控制耦合、外部耦合、公共耦合、内容耦合（最高的耦合）</p><p>耦合程度依次升高。</p></blockquote></li></ul><h4 id="图形工具"><a class="markdownIt-Anchor" href="#图形工具"></a> 图形工具</h4><p>层次图（H图）与结构图（SC图）</p><h4 id="结构化设计方法sd"><a class="markdownIt-Anchor" href="#结构化设计方法sd"></a> 结构化设计方法（SD）</h4><p>将系统的逻辑模型DFD图转换为软件结构图（H图、SC图）</p><h3 id="2-数据设计ppt没有"><a class="markdownIt-Anchor" href="#2-数据设计ppt没有"></a> 2. 数据设计（PPT没有？？）</h3><h2 id="五-详细设计"><a class="markdownIt-Anchor" href="#五-详细设计"></a> 五、详细设计</h2><p>在详细设计阶段，我们要确定每个模块的算法与数据结构，为每个模块设计一组测试用例，编写《详细设计说明书》</p><h3 id="1-详细设计工具"><a class="markdownIt-Anchor" href="#1-详细设计工具"></a> 1. 详细设计工具</h3><p>为了确定每个模块的算法，我们使用了描述算法的工具——<u>程序流程图</u>、<u>N-S盒图</u>以及<u>PAD图</u>。</p><h3 id="2-人机界面设计"><a class="markdownIt-Anchor" href="#2-人机界面设计"></a> 2. 人机界面设计</h3><p>人机界面应该具有一些特性：</p><ul><li>可使用性</li><li>灵活性</li><li>可靠性</li></ul><p>界面设计要遵守的一些原则：</p><ul><li>用户界面适合于软件的功能</li><li>容易理解</li><li>风格一致</li><li>及时反馈信息</li><li>出错处理</li><li>适应各种用户</li><li>国际化</li><li>个性化</li><li>合理的布局</li><li>和谐的色彩</li></ul><h2 id="六-编码"><a class="markdownIt-Anchor" href="#六-编码"></a> 六、编码</h2><p>程序设计语言的特性、程序的设计风格会深刻的影响软件的质量和可维护性。我们编码的目标是要产生正确可靠、简明清晰、具有较高效率的源程序。</p><h2 id="七-测试"><a class="markdownIt-Anchor" href="#七-测试"></a> 七、测试</h2><ul><li>软件测试是为了证明程序有错，而不是证明程序无错误</li><li>一个好的测试用例是在于它能发现至今未发现的错误</li><li>一个成功的测试是发现了至今未发现的错误</li></ul><h3 id="1-测试步骤"><a class="markdownIt-Anchor" href="#1-测试步骤"></a> 1. 测试步骤</h3><ul><li>单元测试：集中对源代码实现的每一个程序模块进行测试</li><li>集成测试：把测试过的模块组装起来，主要对模块间接口开展测试</li><li>确认测试：检查已实现的软件是否满足了需求规格说明书中的各种需求</li><li>系统测试：把经过确认后的软件纳入实际运行环境中，与其他系统成分组合在一起测试。</li></ul><h3 id="2-测试方法"><a class="markdownIt-Anchor" href="#2-测试方法"></a> 2. 测试方法</h3><blockquote><p>Testing is the process of executing a program with the intent of finding errors.</p></blockquote><p>具体可以分为两大类测试方法</p><ul><li>静态测试：主要进行代码复审，检查程序的静态结构，可以采用代码会审、走查、借助静态分析器进行自动化测试。</li><li>动态测试：在设定的测试用例上执行被测程序的过程。<ul><li>黑盒测试</li><li>白盒测试</li></ul></li></ul><h4 id="白盒测试用例的设计"><a class="markdownIt-Anchor" href="#白盒测试用例的设计"></a> 白盒测试用例的设计</h4><p>我们可以在程序流程图的基础上，使用逻辑覆盖法设计白盒测试用例。</p><p><em><strong><u>对于逻辑覆盖法：</u></strong></em></p><ul><li><p>语句覆盖：将程序的每个语句至少执行一次</p></li><li><p>判定覆盖：每个判定的每个分支路径至少执行一次</p></li><li><p>条件覆盖：每个条件的真假两种情况至少执行一次</p><blockquote><p>满足条件覆盖不一定满足判定覆盖</p></blockquote></li><li><p>判定/条件覆盖：每个条件的真假、每个判定的每个分支路径至少执行一次</p></li><li><p>条件组合覆盖：每个判定的所有条件的各种可能组合至少执行一次</p></li></ul><hr /><p>我们也可以在程序同的基础上，使用路径测试法设计白盒测试用例。</p><p><strong><u><em>对于路径测试法：</em></u></strong></p><ul><li>点覆盖：每个节点至少执行一次</li><li>边覆盖：每条边至少执行一次</li><li>路径覆盖：每条路径至少执行一次</li></ul><h4 id="黑盒测试用例设计"><a class="markdownIt-Anchor" href="#黑盒测试用例设计"></a> 黑盒测试用例设计</h4><p>黑盒测试用例设计时，可以采取的方法有等价类划分、边界值分析、错误推测法。</p><h3 id="3-单元测试"><a class="markdownIt-Anchor" href="#3-单元测试"></a> 3. 单元测试</h3><h3 id="4-集成测试"><a class="markdownIt-Anchor" href="#4-集成测试"></a> 4. 集成测试</h3><h3 id="5-确认测试"><a class="markdownIt-Anchor" href="#5-确认测试"></a> 5. 确认测试</h3><h3 id="6-系统测试"><a class="markdownIt-Anchor" href="#6-系统测试"></a> 6. 系统测试</h3><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>测试：是用户在模拟操作环境下进行的测试，软件开发人员与QA人员也应参加</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>测试：是由软件的多个用户在实际操作环境下进行的测试。即是在开发者无法控制的环境下进行的软件现场应用。</p></blockquote><h3 id="7-其他"><a class="markdownIt-Anchor" href="#7-其他"></a> 7. 其他</h3><p>除了上述测试外，测试还可以分为好多种类：</p><ul><li><p>功能测试</p></li><li><p>可靠性测试</p></li><li><p>强度（压力）测试：高并发访问等</p></li><li><p>性能测试：通常与强度测试结合</p><blockquote><p>应该差不多吧</p></blockquote></li><li><p>启动/停止测试</p></li><li><p>回复测试</p></li><li><p>配置测试</p></li><li><p>安全性测试</p></li><li><p>回归测试</p></li></ul><h4 id="8-各种测试工具"><a class="markdownIt-Anchor" href="#8-各种测试工具"></a> 8. 各种测试工具</h4><blockquote><p>体验了一下NUnit系列的JUnit与CPPUnit，感觉很棒</p></blockquote><h2 id="八-软件维护"><a class="markdownIt-Anchor" href="#八-软件维护"></a> 八、软件维护</h2><h2 id="九-面向对象软件工程"><a class="markdownIt-Anchor" href="#九-面向对象软件工程"></a> 九、面向对象软件工程</h2><p>面向对象方法是以对象为核心的软件开发方法，按照人对客观世界认识的规律和解决问题的方法与过程开发软件，描述问题空间与实现在结构上一致。</p><p>**<u>UML</u>**是对象管理组织（OMG）采纳的基于面向对象技术的标准建模语言</p><blockquote><p>Unified Modeling Language——统一建模语言</p></blockquote><blockquote><p>面向对象 = 对象 + 类 + 继承 + 通信</p></blockquote><h3 id="1-uml模型基本组成"><a class="markdownIt-Anchor" href="#1-uml模型基本组成"></a> 1. UML模型基本组成</h3><p>① 要素：Use Case、Actor、Class、Interface</p><p>② 关系：</p><ul><li><p>关联关系：当一个类的对象作为另一个类的成员变量时，两个类之间有关联关系。</p><blockquote><p>聚合关系：整体与部分的关系，整体消失但对象不消失，部分的对象可以被多个整体共享</p><blockquote><p>球队与球员、电脑与CPU主存等</p></blockquote><p>组合关系：整体与部分之间具有很强的所有关系和一致的生命周期，部分不能独立于整体而存在。</p><blockquote><p>活人与跳动的心脏</p></blockquote></blockquote></li><li><p>依赖关系：一个模型元素的变化会影响到另一个的模型元素</p></li><li><p>泛化关系：被称为继承关系，为通信而存在的关系</p></li><li><p>实现关系：类对接口的实现</p></li></ul><p>③ 图：</p><ul><li>静态图：类图、对象图、用例图</li><li>动态图：顺序图、状态图、协作图、活动图</li></ul><h3 id="2-用例图"><a class="markdownIt-Anchor" href="#2-用例图"></a> 2. 用例图</h3><p>Use Case图用于描述拟建系统和外部环境的关系。</p><h4 id="actor"><a class="markdownIt-Anchor" href="#actor"></a> Actor</h4><p>**<u>主导Actor：</u>**初始化Use Case，主动要求得到结果，触发交互活动，<u><em>至少</em></u>有一个。</p><p>其他Actor：仅参与Use Case，在某个时刻与Use Case通信。</p><h4 id="use-case间的关系"><a class="markdownIt-Anchor" href="#use-case间的关系"></a> Use Case间的关系</h4><ul><li><p>Include：包含关系</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201090939411-UseCaseInclude.png" alt="" /></p><blockquote><p>用户不论是对账户内容的增加还是删除，都需要先登录。表明删除Use Case与增加Use Case用例都include（包含）了登录Use Case</p></blockquote></li><li><p>Extend：用例的某一部分是可选的系统行为</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201090942694-UseCaseExtend.png" alt="" /></p><blockquote><p>用户打电话时，可以选择使用呼叫等待或是呼叫转移等增值服务，此时呼叫等待Use Case与呼叫转移Use Case extend了打电话Use Case的功能。</p></blockquote></li><li><p>Generalization</p></li></ul><h4 id="用例规约"><a class="markdownIt-Anchor" href="#用例规约"></a> 用例规约</h4><blockquote><p>用例图是骨架，用例规约是其内在的精髓</p></blockquote><h3 id="3-类图"><a class="markdownIt-Anchor" href="#3-类图"></a> 3. 类图</h3><h3 id="4-序列图"><a class="markdownIt-Anchor" href="#4-序列图"></a> 4. 序列图</h3><ul><li>对象</li><li>对象生存线</li><li>控制焦点</li><li>消息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201091012664-sequence.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUMT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《智能科学技术导论》课程总结</title>
    <link href="/2022/01/04/CUMT%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93_%E3%80%8A%E6%99%BA%E8%83%BD%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/04/CUMT%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93_%E3%80%8A%E6%99%BA%E8%83%BD%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><blockquote><p>虽然这门神奇且考试有点离谱的课今后不再开了，但是总结的东西似乎大概也许会有一点点用吧。</p></blockquote><h1 id="一-算法-算法构造"><a class="markdownIt-Anchor" href="#一-算法-算法构造"></a> 一、算法、算法构造</h1><h2 id="算法性质"><a class="markdownIt-Anchor" href="#算法性质"></a> 算法性质</h2><ul><li>有序性：算法中步骤有执行顺序</li><li>有限性：算法中步骤有限</li><li>明确性：算法包含的每一条指令都是明确可以直接执行的步骤</li><li>终止性：有限时间结束。对于特殊算法，如操作系统却需要永不终止。</li></ul><h2 id="算法构造从界定算法的性质-描述算法的伪码-算法构造的过程三部分进行分析"><a class="markdownIt-Anchor" href="#算法构造从界定算法的性质-描述算法的伪码-算法构造的过程三部分进行分析"></a> 算法构造：从界定算法的性质、描述算法的伪码、算法构造的过程三部分进行分析</h2><p>（一）界定算法的性质：</p><ul><li>算法的定义：算法是一组明确的、可以直接执行之步骤的有限有序集合。</li><li>区分算法内涵与算法描述之间的区别。</li><li>算法的效率与正确性问题：<ul><li>效率是指执行一个算法所要花费的时空代价。</li><li>算法的正确性，则是要确保算法确实解决了给定的问题。目前，证明算法正确性的方法主要有两种途径：软件测试途径、程序正确性证明。</li></ul></li></ul><p>（二）描述算法的伪码</p><ul><li>原语：精确描述算法的形式语言</li><li>伪码：重在表达算法思想的非正式符号系统，既具有直观方便性的优点，又忽略了严格语法的规范性。</li></ul><p>（三）算法构造的过程</p><p>从算法发现的角度看，可以将解决问题的一般原理对应到如下这样四个阶段上：</p><ul><li>阶段1：理解问题</li><li>阶段2：寻找一个可能解决问题的算法过程</li><li>阶段3：阐明算法并且用<em>程序</em>将其表达出来</li><li>阶段4：从准确度以及作为解决其他问题的一个工具的潜力这两个方面来评估这个程序</li></ul><h2 id="算法结构"><a class="markdownIt-Anchor" href="#算法结构"></a> 算法结构</h2><ul><li>选择结构：一般采用条件语句。选择结构本身不会增加计算复杂性。</li><li>迭代结构：一组指令以循环方式重复执行。如果表的长度为n的话，那么平均需要计算n/2计算步，因此算法的计算复杂性为O（n）。</li><li>递归结构：通过将一组指令当作自身的一个子程序进行调用来进行的。如果表的长度为n的话，那么平均需要计算的递归深度为log2n，因此算法的计算复杂性为O（log2n）</li></ul><h1 id="二-自动导航"><a class="markdownIt-Anchor" href="#二-自动导航"></a> 二、自动导航</h1><h2 id="目前解决机器人自动导航问题的主要环节大致有"><a class="markdownIt-Anchor" href="#目前解决机器人自动导航问题的主要环节大致有"></a> 目前解决机器人自动导航问题的主要环节大致有：</h2><ul><li><p>地图构建：明确机器人活动范围的整体路线及其各种坐标参考标志物</p></li><li><p>定位：通过一定的检测手段来获取机器人在空间中的位置、方向、环境信息，并据此建立动态环境模型</p></li><li><p>路径规划：寻找最优或极优无障路径</p><blockquote><p>引导机器人安全移动到达目的地</p></blockquote></li><li><p>躲避障碍：给出灵活躲避障碍的策略，特别是非固定障碍的躲避策略。</p></li></ul><h2 id="机器人自动导航目前主要采用的方法包括"><a class="markdownIt-Anchor" href="#机器人自动导航目前主要采用的方法包括"></a> 机器人自动导航目前主要采用的方法包括：</h2><ul><li>基于预先保存的地图进行导航，主要采用路径跟踪与避障技术来完成导航任务。</li><li>通过动态创建的地图进行导航，需要<strong>利用各种传感器</strong>来获取环境与距离信息，<strong>动态</strong>建立即时环境的几何模型或拓扑地图，然后引导机器人导航任务的完成。</li><li>无地图试探性导航，利用对环境信息的<strong>实时检测技术</strong>来获取各种对周边环境物体的识别，作为导航依据。</li></ul><h1 id="三-机器歌舞"><a class="markdownIt-Anchor" href="#三-机器歌舞"></a> 三、机器歌舞</h1><h2 id="具体地说为了完成机器歌舞要实现六个核心模块的构建及其实现工作"><a class="markdownIt-Anchor" href="#具体地说为了完成机器歌舞要实现六个核心模块的构建及其实现工作"></a> 具体地说，为了完成机器歌舞，要实现六个核心模块的构建及其实现工作：</h2><ul><li><strong>音乐解析模块</strong>主要负责对音乐中所包含的节奏、旋律等信息的解析。</li><li><strong>音乐情感检测和标注模块</strong>是在音乐特征分析的基础上，通过引入情感模型，并采用情感检测算法，实现对音乐情感的检测和情感的自动标注，为<strong>音乐与舞蹈动作匹配模块</strong>提供有用的信息资源。</li><li><strong>舞蹈动作关联分析模块</strong>实在拥有大量特征舞蹈单元的原始动作库基础上，依据音乐的情感特征对各特征单元进行动作风格分类，并对属性和关联性做进一步的研究，分析归纳若干舞蹈动作关联约束，并据此将动作中所有动作单元组织成一张有向网，为系统快速有效的进行舞蹈编排做铺垫。</li><li><strong>音乐舞蹈匹配模块</strong>是以音乐情感特征标注文件以及舞蹈动作序列属性描述文件作为输入，综合考虑音乐的情感特征和舞蹈动作序列的情感属性，利用相应的舞蹈动作选择编排最优算法。最终生成完整的且与音乐内涵最吻合的舞蹈动作序列。</li><li><strong>动漫人物展示模块</strong>主要负责对音乐的情感内涵、语音以及舞蹈动作进行同步表达，主要以舞蹈的形式并伴有姿态语言和面部表情。</li><li><strong>歌舞动作控制模块</strong>主要负责智能机器人歌舞动作的实时控制与协调，保证机器人舞蹈动作的连贯性、平衡性和可观赏性。</li></ul><p><em>机器歌舞自主创作的主要问题并不在能否产生规定的动作序列，而在于机器人创作的序列动作前后是否具有动作的连贯性、风格的一致性和表演的艺术性。</em></p><blockquote><p>写的真好啊！</p></blockquote><h2 id="目前仿人机器人歌舞存在的主要问题是"><a class="markdownIt-Anchor" href="#目前仿人机器人歌舞存在的主要问题是"></a> 目前，仿人机器人歌舞存在的主要问题是</h2><ul><li>没有考虑人类歌舞专业人员学习和创作歌舞的规律</li><li>仅仅学习歌舞动作本身，而不是像人类歌舞专业人员一样通过想象来创新歌舞动作</li><li>没有考虑歌舞创新和传承之间的平衡问题</li><li>缺乏一种通用的仿人机器人歌舞智能学习与创作模型，可以应用于任意仿人机器人硬件平台上完成优美歌舞的学习和创作。</li></ul><h1 id="四-脑机接口"><a class="markdownIt-Anchor" href="#四-脑机接口"></a> 四、脑机接口</h1><h2 id="脑机接口技术主要包括两种不同类型的研究工作"><a class="markdownIt-Anchor" href="#脑机接口技术主要包括两种不同类型的研究工作"></a> 脑机接口技术主要包括两种不同类型的研究工作：</h2><ul><li><p>Type1：实时采集大规模的脑活动信息用以控制人工制作的设备</p></li><li><p>Type2：用人工产生的电信号刺激脑组织，将特定的感知信息直接传给人大脑。</p><blockquote><p>本章着重介绍第一种类型</p></blockquote></li></ul><h2 id="可以用于脑机接口的脑电信号主要包括"><a class="markdownIt-Anchor" href="#可以用于脑机接口的脑电信号主要包括"></a> 可以用于脑机接口的脑电信号主要包括：</h2><ul><li><p>脑电节律波（EEG）</p></li><li><p>诱发电位或事件相关电位（ERP）</p></li><li><p>神经元电脉冲信号</p><blockquote><p>前两种通过脑电仪采集，后一种采用内值微电极来获取。</p><p>考虑到内置微电机的损伤性，因此一般都采用脑电仪作为脑机接口的主要工具。</p></blockquote></li></ul><h2 id="一般脑机接口涉及到五个不同功能模块的实现"><a class="markdownIt-Anchor" href="#一般脑机接口涉及到五个不同功能模块的实现"></a> 一般脑机接口涉及到五个不同功能模块的实现：</h2><ul><li><p>脑电信号的采集：设计脑电仪电极分布模式，使脑电仪最有效的采集所需信号。</p></li><li><p>脑电信号的预处理：滤波方法，提高信噪比</p><blockquote><p>通俗点说，去除无关信号，保留强化有效信号</p></blockquote></li><li><p>特征提取：根据信号特点，针对具体任务，给出面向任务的特征描述向量，并从信号中提取具体的特征向量值。</p></li><li><p>模式识别：根据特征向量值，分析，的而出脑电模式类别。</p><blockquote><p>支持向量机，线性判别分析，人工神经网络，似乎就是一个分类问题</p></blockquote></li><li><p>实施控制：根据获得的含义理解（模式识别结果），实时控制机器完成相应功能。</p></li></ul><h2 id="国内外开发的著名脑机接口系统"><a class="markdownIt-Anchor" href="#国内外开发的著名脑机接口系统"></a> 国内外开发的著名脑机接口系统</h2><ul><li>德国柏林脑机接口系统</li><li>美国Wadsworth中心的脑机接口系统</li><li>奥地利craz大学的脑机接口系统</li><li>思维翻译机</li><li>清华大学脑机接口系统</li><li>浙江大学猴子意念控制系统</li></ul><h1 id="五-知觉组织"><a class="markdownIt-Anchor" href="#五-知觉组织"></a> 五、知觉组织</h1><h2 id="整体知觉组织规律"><a class="markdownIt-Anchor" href="#整体知觉组织规律"></a> <em>整体知觉组织规律：</em></h2><ul><li>接近律：视觉更容易根据部分彼此之间的临近或接近关系而组合起来，并得出整体形象。</li><li>相似律：具有某种特征（形状、颜色等）相似的项目，不被接近因素掩盖，则倾向于联合在一起。</li><li>连续律：如果一套点子中有些点显得连续或者完成一个有规律的系列，或拓展成一条简单的曲线，则这些点更容易组织起来，联合在一起。</li><li>封闭律：各种视觉组织律会产生竞争甚至冲突，此时最终知觉的结果形象往往取决于哪种因素更为重要了，其中封闭的图案往往有较大优势。</li><li>简单律：在其它因素相同时，人们将把视觉对象看成有组织的<strong>简单规则图形。</strong></li></ul><h1 id="六-人类运动程序"><a class="markdownIt-Anchor" href="#六-人类运动程序"></a> 六、人类运动程序</h1><h2 id="人类运动程序的产生过程"><a class="markdownIt-Anchor" href="#人类运动程序的产生过程"></a> 人类运动程序的产生过程：</h2><ul><li>根据运动动机愿望、获得的感觉信息以及人体自身状况，大脑联络皮层产生运动动作的粗略规划</li><li>大脑皮层对粗略规划进行分析、处理与解释，形成更为详细的运动系列</li><li>对运动系列的时空图式进行内部模拟</li><li>驱动运动系列的实施。</li></ul><h1 id="七-智慧城市"><a class="markdownIt-Anchor" href="#七-智慧城市"></a> 七、智慧城市</h1><h2 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> 1.定义</h2><p>​智慧城市是指充分借助物联传感网、无线移动网、全球互联网，利用先进的信息技术手段，特别是智能技术，构建城市发展的智慧环境。</p><blockquote><p>智慧城市涉及到智能家居、智能楼宇、路网监控、智能医疗、智能交通、城市管理、城市生态、智能教育与数字生活等诸多领域，其目标就是要形成基于海量信息和智能处理的生活方式、产业发展、社会管理等模式，面向未来构建全新的城市形态。</p></blockquote><h2 id="2智慧城市的整体框架"><a class="markdownIt-Anchor" href="#2智慧城市的整体框架"></a> 2.智慧城市的整体框架</h2><p>在智慧城市的架构中，无线网、互联网、物联网等<strong>三网一体</strong></p><ul><li>智能家居是智慧城市的<strong>单元</strong></li><li>智能交通、智能医疗、智能楼宇、智能教育、智能能源、智能环境等是智慧城市的<strong>功能实现</strong></li><li>智能识别、移动计算、信息融合、云端计算等则是智慧城市的<strong>关键技术</strong></li></ul><h2 id="3智慧城市主要特征"><a class="markdownIt-Anchor" href="#3智慧城市主要特征"></a> <em>3.智慧城市主要特征</em></h2><p>从技术层面看，智慧城市的主要特征包括：</p><ul><li><p>由传感器和智能终端构成的物联网覆盖整个城市，可以对城市运行的核心系统进行全方位的感知、监控和分析；</p></li><li><p>物联网、移动网、互联网三网融合，为城市智能管理提供有效的信息流通平台；</p></li><li><p>在智能设施的基础上，全面开展智能化政务管理、企业经营、市民生活等创新性开发应用；</p></li><li><p>城市主要核心系统之间实现高效协同运作，实现城市最佳运行状态。如下图所示。</p></li></ul><p>对于物联感知层，为了实现城市有效的物联感知能力，需要射频识别技术、电子传感技术、智能嵌入技术的支撑。</p><p>对于网络通信层，城市网络通信系统应该具备以下主要特性：</p><ul><li>三网融合一体</li><li>移动通信全覆盖</li><li>通信协议全面兼容</li><li>宽带光纤网络</li><li>泛在的物联网</li></ul><p>对于数据服务层，它为各类智慧应用系统提供数据支撑服务。为了有效利用、管理各类数据资源，需要进行<strong>数据融合</strong>和<strong>服务融合</strong>。</p><p>然后，在此基础上就可以开发各类智慧城市的应用系统，即智慧应用层。</p><h2 id="4智慧城市应用系统"><a class="markdownIt-Anchor" href="#4智慧城市应用系统"></a> 4.智慧城市应用系统</h2><blockquote><p>看看对各个应用的解释吧。考试现场编！冲！</p></blockquote><ul><li>智能公共服务</li><li>智能社会管理</li><li>智能企业服务</li><li>智能安居服务</li><li>智能教育服务</li><li>智能文化服务</li><li>智能商务管理</li><li>智能医疗保障</li><li>智能交通系统</li><li>智能农村服务</li><li>智能安防系统</li><li>智能政务管理</li></ul><h2 id="5智慧城市建设涉及到的主要核心技术"><a class="markdownIt-Anchor" href="#5智慧城市建设涉及到的主要核心技术"></a> 5.智慧城市建设涉及到的主要核心技术</h2><blockquote><p>上述列举的建设项目，都需要智能技术等综合核心技术的支持。</p></blockquote><ul><li>智能感知识别技术</li><li>智能移动计算技术</li><li>智能信息融合技术</li></ul><p>另外，由于数据处理规模庞大、关系复杂，需要建立<strong>云计算数据中心</strong>，保证诸功能系统的有效运行。</p><h2 id="6对海量数据的挖掘分析需要考虑三个要点步骤"><a class="markdownIt-Anchor" href="#6对海量数据的挖掘分析需要考虑三个要点步骤"></a> 6.对海量数据的挖掘分析，需要考虑三个要点步骤</h2><blockquote><p>无论是智慧城市架构，还是涉及到具体智能方法，从核心关键实现技术的角度，大<strong>数据及其挖掘分析方法</strong>都是其中信息综合处理中的关键</p></blockquote><ul><li><p>确定数据挖掘的目标，以便采取不同的数据挖掘方法。</p></li><li><p>构造相应的数据挖掘算法，确定模型和参数</p></li><li><p>运用构造的算法具体实施数据挖掘任务，提取有效的知识，并用某种方式表达出来。</p></li></ul><h2 id="7可供选择的数据挖掘目标及其方法大致分为如下几个方面"><a class="markdownIt-Anchor" href="#7可供选择的数据挖掘目标及其方法大致分为如下几个方面"></a> 7.可供选择的数据挖掘目标及其方法大致分为如下几个方面</h2><ul><li><p>数据关联分析</p></li><li><p>自动分类预测</p></li><li><p>数据聚类分析</p></li><li><p>离群异常分析</p></li><li><p>数据演化分析</p></li></ul><h2 id="8智慧城市的优势-主要作用"><a class="markdownIt-Anchor" href="#8智慧城市的优势-主要作用"></a> 8.智慧城市的优势、主要作用</h2><ul><li><p>能够降低城市运行成本、提高行政效率</p></li><li><p>能够深化公共服务层次、促进政府职能转变</p></li><li><p>政府权力运作公开透明、城市管理客观化</p></li><li><p>各级机构、事业单位高度自治、促进事业发展</p></li><li><p>保障企业创新活力、促进经济增长</p></li><li><p>拓宽信息传播渠道、促进就业</p></li><li><p>引领科技创新、振兴新兴产业</p></li><li><p>改善民生、提升市民生活质量</p></li></ul><h1 id="八-语音识别"><a class="markdownIt-Anchor" href="#八-语音识别"></a> 八、语音识别</h1><h2 id="语音识别过程分为三个方面内容"><a class="markdownIt-Anchor" href="#语音识别过程分为三个方面内容"></a> 语音识别过程分为三个方面内容：</h2><ul><li>特征提取</li><li>模式匹配</li><li>模型训练</li></ul><h2 id="针对非特定人的语音识别方法大致包括"><a class="markdownIt-Anchor" href="#针对非特定人的语音识别方法大致包括"></a> 针对非特定人的语音识别方法大致包括</h2><ul><li>隐马尔可夫模型方法，也是语音识别的主流方法</li><li>基于知识（利用构词、句法、语义、会话背景等方面的知识）的语音识别方法，并与大规模语料统计模型相结合；</li><li>神经网络、遗传算法、免疫算法、蚁群算法等自然计算方法。</li></ul><h2 id="根据语音识别目标的不同语音识别的任务大致分为三类"><a class="markdownIt-Anchor" href="#根据语音识别目标的不同语音识别的任务大致分为三类"></a> 根据语音识别目标的不同，语音识别的任务大致分为三类：</h2><ul><li>孤立词识别（isolatedwordrecognition)</li><li>关键词识别（keywordspotting)</li><li>连续语音识别。</li></ul><h2 id="根据发音对象的不同还可以分为"><a class="markdownIt-Anchor" href="#根据发音对象的不同还可以分为"></a> 根据发音对象的不同，还可以分为：</h2><ul><li>特定人语音识别</li><li>非特定人语音识别。</li></ul><h2 id="语音识别主要需要解决的五个问题"><a class="markdownIt-Anchor" href="#语音识别主要需要解决的五个问题"></a> 语音识别主要需要解决的五个问题：</h2><ul><li>话语要素的分割问题：将连续的话语分解为词、音素等基本单位</li><li>确定语音模式的区分标准：不同人有不同的语音模式，同一人在不同场合、状态、时期也有不同的语音模式。</li><li>模糊性问题：说话含糊不清，语言中同义词现象，使语音识别成为依赖于上下文与会话背景的复杂研究课题。</li><li>词语发音的动态性：单个字母或词、字的语音特性会受到上下文影响而变化，包括读音、重音、音调、音量、发音速度等方面的改变。</li><li>环境噪音干扰：人类可以在嘈杂环境下排除干扰，但是机器没有有效解决方法。</li></ul><h1 id="九-大脑皮层运动"><a class="markdownIt-Anchor" href="#九-大脑皮层运动"></a> 九、大脑皮层运动</h1><blockquote><p>课本p85，5.1.2，说的挺好的，感觉就是它没错了！</p></blockquote><h2 id="人脑机制从人脑结构功能定位-神经连接网络-心脑行为自主对人脑机制进行分析"><a class="markdownIt-Anchor" href="#人脑机制从人脑结构功能定位-神经连接网络-心脑行为自主对人脑机制进行分析"></a> 人脑机制——从人脑结构功能定位、神经连接网络、心脑行为自主对人脑机制进行分析：</h2><ul><li><strong>人脑结构功能定位</strong>：任何叶区的功能划分都不会是绝对明确的，确切的功能性叶区边界也是不存在的；并因人而异的。脑功能是分布搭配式的，因此某个功能消失并不一定引起所有功能的丧失。</li><li><strong>神经连接网络</strong>：人脑中的神经系统看作是由神经细胞及其突触联系所构成的一张巨大无比的神经网络。</li><li><strong>心脑行为自主</strong>：心脑行为从根本上讲是神经系统自组织活动本身的外效表现。</li></ul><h2 id="运动神经系统由三个水平的神经结构分级构成从低到高分别是"><a class="markdownIt-Anchor" href="#运动神经系统由三个水平的神经结构分级构成从低到高分别是"></a> 运动神经系统由三个水平的神经结构分级构成，从低到高分别是：</h2><ul><li><p>脊髓：最低水平的运动控制结构</p></li><li><p>脑干的下行系统：包括内测和外侧两个部分。</p></li><li><p>大脑皮层的运动区：详细说明见下一点</p><blockquote><p>在整个运动神经系统中，大脑皮层可以通过脑干下行系统来对脊髓进行间接控制。</p></blockquote></li></ul><h2 id="大脑皮层运动区的详细说明"><a class="markdownIt-Anchor" href="#大脑皮层运动区的详细说明"></a> 大脑皮层运动区的详细说明</h2><p>大脑运动皮层为运动制定正确策略。通过各种感觉传入，来获得外界物体在空间中相互关系的信息。</p><p>大脑皮层运动区是运动控制的最高水平中枢，大致构成包括有：</p><ul><li><p>初级运动皮层</p></li><li><p>外侧前运动皮层或前运动区</p></li><li><p>辅助运动区</p><blockquote><p>后两个部分均有神经纤维投射到初级运动皮层。而三个部分则均直接投射至脊髓或经脑干下行系统影响脊髓。</p></blockquote></li></ul><h1 id="十-知觉视觉感知"><a class="markdownIt-Anchor" href="#十-知觉视觉感知"></a> 十、知觉/视觉感知</h1><h2 id="从视觉神经通路-知觉组织规律-视觉感知经验三方面阐述"><a class="markdownIt-Anchor" href="#从视觉神经通路-知觉组织规律-视觉感知经验三方面阐述"></a> 从视觉神经通路、知觉组织规律、视觉感知经验三方面阐述：</h2><ul><li><p>视觉神经通路：在视觉通路中，各层次神经细胞普遍是以相互作用的方式进行通信的。整个视觉通路中的神经联接和排列方式，决定了具有引起神经细胞活动方式的视觉刺激或辩认。</p></li><li><p>知觉组织规律：格式塔心理学派将反映这种整体知觉的规律归纳为一些普遍性规则，称为知觉组织律。整体知觉的组织规律还其他一些规律，分别是：接近律、相似律、连续律、封闭律、简单律。</p></li><li><p>视觉感知经验：人类所具备的视觉恒常性和容错性，难以为机械精确、永远无错的算法方式所描述。</p></li></ul><h2 id="视觉感知经验"><a class="markdownIt-Anchor" href="#视觉感知经验"></a> 视觉感知经验</h2><ul><li>恒常性：主要来自于经验和比较</li><li>容错性：有时我们的视觉会得出错误的结论，产生幻觉或错觉。因为经验导致的错觉，人类的视觉不会因为错觉而否认经验，因为经验是人类赖以生存的基础。</li></ul><h1 id="十一-机器人社会行为"><a class="markdownIt-Anchor" href="#十一-机器人社会行为"></a> 十一、机器人社会行为</h1><h2 id="下面列举了一些机器人应该学会的最基本社会行为这样可以增加机器人的社交能力"><a class="markdownIt-Anchor" href="#下面列举了一些机器人应该学会的最基本社会行为这样可以增加机器人的社交能力"></a> 下面列举了一些机器人应该学会的最基本社会行为，这样可以增加机器人的社交能力。</h2><ul><li>身份认知：机器人从中学会在当事与非当事人的身份转换。</li><li>讨回物品：当A把物体扔给B时，机器人会走向B并将物体要回。</li><li>冻结身份：在身份转换时，机器人必须静止不动（“冻结”）直到身份确定。</li><li>引导他人：机器人引导他人开展活动。</li><li>寻找物品：寻找被他人占有的物品，尝试去向他们索要该物品。</li></ul><h1 id="十二-视觉计算理论"><a class="markdownIt-Anchor" href="#十二-视觉计算理论"></a> 十二、视觉计算理论</h1><h2 id="视觉计算的过程"><a class="markdownIt-Anchor" href="#视觉计算的过程"></a> 视觉计算的过程</h2><ul><li>图像获取：通过某种视觉图像采集设备，比如相机、遥感仪、雷达等，获取二维、三维或者图像序列</li><li>预处理：对于获取的图像，进行各种滤波、矫正处理，使质量更好，效果更佳</li><li>特征提取：根据研究目标不同，获取描述图像的各种基本要素，比如边缘与线条、区域与纹理、深度与运动信息等，属于低层信息处理阶段。</li><li>区域分割：对获取的<strong>特征集合</strong>初步整合，将图像分割成各个有机组成部分，属于中层信息处理阶段。</li><li>高级处理：或对图像分类、或理解图像含义、或进行景物分析或识别视觉目标、或跟踪视觉目标，都需要不同的高级计算处理，属于高层信息处理阶段</li></ul><p>如果不考虑视觉图像的获取与预处理，那么上述的后三个步骤构成了视觉计算的主要三个环节：</p><ul><li>差异性信息检测：确定局部性质，灰度、梯度、速度等</li><li>相似性参数分析：确定几何属性，边界、区域、纹理等</li><li>综合性含义理解：确定语义关系，描述、匹配、推理等</li></ul><h2 id="马尔视觉计算理论"><a class="markdownIt-Anchor" href="#马尔视觉计算理论"></a> 马尔视觉计算理论</h2><blockquote><p>9-景物理解-2-马尔视觉计算理论</p></blockquote><blockquote><p>机器要实现三维景物的理解计算，首先必须要给出可以进行<strong>形式化表征</strong>的计算策略和方法。</p><p>马尔认为，视觉感知首先是一个<strong>信息处理过程</strong>，是要从图像中发现外部世界中有什么以及处在什么位置。</p><p>因此，视觉对象的<strong>内部表征</strong>就成为视觉计算的主要载体。</p><p>于是视觉计算任务就成为如何<strong>根据给定的图像，来获取个层次的内部表征，直至恢复图像的三维景物。</strong></p></blockquote><h3 id="马尔从三个层次建立视觉计算理论"><a class="markdownIt-Anchor" href="#马尔从三个层次建立视觉计算理论"></a> 马尔从三个层次建立视觉计算理论：</h3><ul><li>计算理论：确定视觉计算的目的</li><li>表征与算法：如何实现视觉计算任务，确定输入输出的表征，给出不同表征之间转换的算法。t</li><li>硬件实现：在物理上如何实现视觉表征及其转换算法。</li></ul><h3 id="第二个层次是视觉计算理论的核心内容为此马尔提出了具体的四级表征"><a class="markdownIt-Anchor" href="#第二个层次是视觉计算理论的核心内容为此马尔提出了具体的四级表征"></a> 第二个层次是视觉计算理论的核心内容，为此，马尔提出了具体的四级表征</h3><ul><li>图像：表达光强，用像素表征</li><li>要素图：表达二维图像中的重要变化信息及其分布。比如边界、不连续点、斑点、有效线段、边缘片段等。</li><li>2.5维图：在<strong>以观察者为中心的坐标系</strong>中，将可见朝向、大致深度及其不连续轮廓表达清楚。比如表面要素的朝向、距离观察者的深度、深度上不连续点、表面朝向不连续点等。</li><li>3维模型：在<strong>以物体为中心的坐标系</strong>中，景物用体积基元和面积基元给出的层次模块化表征。</li></ul><h3 id="对上述各个层次表征的获取正好对应视觉计算不同步骤的计算分析处理阶段涉及到"><a class="markdownIt-Anchor" href="#对上述各个层次表征的获取正好对应视觉计算不同步骤的计算分析处理阶段涉及到"></a> 对上述各个层次表征的获取，正好对应视觉计算不同步骤的计算分析处理阶段，涉及到：</h3><ul><li>图形检测、运动检测、空间检测、分形检测等<strong>差异性低层处理技术</strong></li><li>边线合成、区域生成、纹理识别、表面恢复等<strong>相似性中层处理技术</strong></li><li>景物匹配、含义推断、知识习得、目标规划等<strong>理解性高层处理技术。</strong></li></ul><h1 id="十三-视觉选择性注意机制"><a class="markdownIt-Anchor" href="#十三-视觉选择性注意机制"></a> 十三、视觉选择性注意机制</h1><h2 id="人类视觉活动复杂特别是主观经验也会决定人类视觉结果"><a class="markdownIt-Anchor" href="#人类视觉活动复杂特别是主观经验也会决定人类视觉结果"></a> 人类视觉活动复杂，特别是主观经验也会决定人类视觉结果</h2><p>​相对于机器而言，人类有着复杂的视觉活动能力。</p><p>​人类在眼睛收受信息时，并非对环境中所接触到的一切刺激特征全盘接收的。根本原因就是人类所获取的视觉信息、所获得的视觉经验，都是主动选择性的。</p><blockquote><p>写的真好！</p></blockquote><h2 id="由此得出结论人类对物体的知觉不能仅仅通过对物体各组成要素的感知把握还需要一个整体概念做指导"><a class="markdownIt-Anchor" href="#由此得出结论人类对物体的知觉不能仅仅通过对物体各组成要素的感知把握还需要一个整体概念做指导"></a> 由此得出结论——人类对物体的知觉，不能仅仅通过对物体各组成要素的感知把握，还需要一个整体概念做指导。</h2><p>​很明显，对于一个物体的知觉，必须通过对这一物体的各组成要素进行感知把握之后才能完成；然而如果在感知把握时，没有一个整体的概念作指导，那么对这个物体的知觉就连一步也不能深入下去。</p><p>​观察者能看见什么，不仅取决于外界呈现的视觉刺激，还取决于他主观的注意。外界刺激只有在主观意识活动的参与下，才能形成视觉形象的显现。</p><h2 id="人类视觉的主动性有两个作用除了上述描述的主动选择发现线索外还有一个重要特点是主观意念并非总是唯一"><a class="markdownIt-Anchor" href="#人类视觉的主动性有两个作用除了上述描述的主动选择发现线索外还有一个重要特点是主观意念并非总是唯一"></a> 人类视觉的主动性有两个作用，除了上述描述的“主动选择发现线索”外，还有一个重要特点是主观意念并非总是唯一。</h2><p>​当然，在这种主观意念起作用的情况中，除了视觉会主动有选择地去“发现”线索以构成有意义的整体感知外，还有一个重要的特点就是主观意念往往并非总是唯一的，</p><h2 id="机器视觉的不足"><a class="markdownIt-Anchor" href="#机器视觉的不足"></a> 机器视觉的不足</h2><p>​遗感的是，通过运动序列图像的分析和跟踪，机器确实可以去选择有效的线索，但由于机器缺乏主观意向性，因此主观意念就将成为机器视觉的真正困境。</p><h2 id="作者试探性的给出了一种动态场景主动理解的视觉计算模型"><a class="markdownIt-Anchor" href="#作者试探性的给出了一种动态场景主动理解的视觉计算模型"></a> 作者试探性的给出了一种动态场景主动理解的视觉计算模型</h2><p>​目前机器视觉系统的构建，主要都是建立在视觉信息处理的bottom-up策略之上的，如马尔的计算理论那样，很少运用人类视觉经验的top-down策略。</p><p>​为了弥补这样的不足，<strong>构建未来的机器视觉系统，我们可以依赖人类视觉认知机制的研究成果，引入联想觉知机制，形成一种具有觉知能力的视觉感知动态计算模型</strong></p><h2 id="以下是按照如上构想提出的视觉动态觉知的计算模型"><a class="markdownIt-Anchor" href="#以下是按照如上构想提出的视觉动态觉知的计算模型"></a> 以下是按照如上构想提出的视觉动态觉知的计算模型</h2><div align=center><img src="https://cdn.jsdelivr.net/gh/Chen-Wang-JY/pictures@main/img/202201061112654-一种视觉动态觉知模型.png" style="zoom: 67%;" /></div><p>​</p><p>​在该模型中，除了必须的Bottom-Up视觉加工处理外，主要加入了体现top-down计算策略的“联想记忆”和“整体觉知”模块。然后将Bottom-Up和top-down两者加工策略相汇合，整合形成实时动态场景中关注对象觉知，从而解决动态场景的视觉计算问题。</p><h2 id="作者总结"><a class="markdownIt-Anchor" href="#作者总结"></a> 作者总结</h2><p>​景物理解的主动视觉，特别是主观意念参与的知觉过程是与人类整个心智能力，包括意识、情感、经验等等在内的机能密不可分，而其中的视觉选择性注意是人类视觉系统能够开展主动感知活动的基础。因此，希望机器视觉也能够部分地模仿人类景物理解能力，首先必须解决主动视觉机制的计算实现问题。我们期待有朝一日，在机器主动视觉的计算模型及其系统应用方面，有长足的进步。</p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUMT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/12/12/%5B0%5D_hello-world/"/>
    <url>/2021/12/12/%5B0%5D_hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
